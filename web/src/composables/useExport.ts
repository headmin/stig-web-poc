import { ref } from "vue";
import JSZip from "jszip";
import { saveAs } from "file-saver";
import type { Rule } from "@/types/benchmark";

export type ExportFormat = "legacy" | "gitops";

interface ExportOptions {
  rules: Rule[];
  profileName: string;
  includeFixes: boolean;
  splitBySeverity: boolean;
  format: ExportFormat;
}

const isExporting = ref(false);

export function useExport() {
  async function exportToZip(options: ExportOptions) {
    const { rules, profileName, includeFixes, splitBySeverity, format } =
      options;

    isExporting.value = true;

    try {
      const zip = new JSZip();
      const folder = zip.folder(profileName)!;

      if (format === "gitops") {
        // Fleet GitOps format - simple flat structure
        generateGitOpsStructure(folder, rules, splitBySeverity);
      } else {
        // Legacy format with nested structure
        generateLegacyStructure(folder, rules, splitBySeverity);
      }

      // Include fix files if requested (Fleet-aligned structure)
      if (includeFixes && format === "gitops") {
        // Fleet structure: lib/windows/scripts/ and lib/windows/configuration-profiles/
        const libFolder = folder.folder("lib") || folder.folder("lib")!;
        const windowsFolder =
          libFolder.folder("windows") || libFolder.folder("windows")!;
        const scriptsFolder = windowsFolder.folder("scripts")!;
        const configProfilesFolder = windowsFolder.folder(
          "configuration-profiles",
        )!;

        for (const rule of rules) {
          if (rule.fix) {
            if (rule.fix.type === "ps1") {
              scriptsFolder.file(rule.fix.filename, rule.fix.content);
            } else if (rule.fix.type === "xml") {
              configProfilesFolder.file(rule.fix.filename, rule.fix.content);
            }
          }
        }
      } else if (includeFixes) {
        // Legacy format: fixes/xml and fixes/ps1
        const fixesFolder = folder.folder("fixes")!;
        const xmlFolder = fixesFolder.folder("xml")!;
        const ps1Folder = fixesFolder.folder("ps1")!;

        for (const rule of rules) {
          if (rule.fix) {
            if (rule.fix.type === "xml") {
              xmlFolder.file(rule.fix.filename, rule.fix.content);
            } else if (rule.fix.type === "ps1") {
              ps1Folder.file(rule.fix.filename, rule.fix.content);
            }
          }
        }
      }

      // Generate README
      folder.file(
        "README.md",
        generateReadme(rules, profileName, includeFixes, format),
      );

      // Generate ZIP and download
      const blob = await zip.generateAsync({ type: "blob" });
      saveAs(blob, `${profileName}.zip`);
    } finally {
      isExporting.value = false;
    }
  }

  return {
    exportToZip,
    isExporting,
  };
}

// Generate Fleet GitOps structure (simple, flat format)
function generateGitOpsStructure(
  folder: JSZip,
  rules: Rule[],
  splitBySeverity: boolean,
) {
  const libFolder = folder.folder("lib")!;
  const windowsFolder = libFolder.folder("windows")!;
  const policiesFolder = windowsFolder.folder("policies")!;

  if (splitBySeverity) {
    // Split into separate files by severity
    const highRules = rules.filter((r) => r.severity === "high");
    const mediumRules = rules.filter((r) => r.severity === "medium");
    const lowRules = rules.filter((r) => r.severity === "low");

    if (highRules.length > 0) {
      policiesFolder.file(
        "stig-high.policies.yml",
        generateGitOpsPoliciesYaml(highRules),
      );
    }
    if (mediumRules.length > 0) {
      policiesFolder.file(
        "stig-medium.policies.yml",
        generateGitOpsPoliciesYaml(mediumRules),
      );
    }
    if (lowRules.length > 0) {
      policiesFolder.file(
        "stig-low.policies.yml",
        generateGitOpsPoliciesYaml(lowRules),
      );
    }
  } else {
    // All in one file
    policiesFolder.file("stig.policies.yml", generateGitOpsPoliciesYaml(rules));
  }

  // Generate default.yml that references the policies
  const policyPaths = splitBySeverity
    ? [
        rules.some((r) => r.severity === "high")
          ? "- ./lib/windows/policies/stig-high.policies.yml"
          : null,
        rules.some((r) => r.severity === "medium")
          ? "- ./lib/windows/policies/stig-medium.policies.yml"
          : null,
        rules.some((r) => r.severity === "low")
          ? "- ./lib/windows/policies/stig-low.policies.yml"
          : null,
      ]
        .filter(Boolean)
        .join("\n")
    : "- ./lib/windows/policies/stig.policies.yml";

  folder.file(
    "default.yml",
    `# Fleet GitOps Configuration
# Generated by STIG Benchmark Builder
# See: https://fleetdm.com/docs/configuration/yaml-files

org_settings:
  server_settings:
    server_url: https://your-fleet-server.com

policies:
${policyPaths}
`,
  );
}

// Generate legacy structure (nested with apiVersion/kind)
function generateLegacyStructure(
  folder: JSZip,
  rules: Rule[],
  splitBySeverity: boolean,
) {
  const policiesFolder = folder.folder("policies")!;

  if (splitBySeverity) {
    const highRules = rules.filter((r) => r.severity === "high");
    const mediumRules = rules.filter((r) => r.severity === "medium");
    const lowRules = rules.filter((r) => r.severity === "low");

    if (highRules.length > 0) {
      policiesFolder.file("high.yml", generateLegacyPoliciesYaml(highRules));
    }
    if (mediumRules.length > 0) {
      policiesFolder.file(
        "medium.yml",
        generateLegacyPoliciesYaml(mediumRules),
      );
    }
    if (lowRules.length > 0) {
      policiesFolder.file("low.yml", generateLegacyPoliciesYaml(lowRules));
    }
  } else {
    policiesFolder.file("policies.yml", generateLegacyPoliciesYaml(rules));
  }
}

// Generate Fleet GitOps YAML format (simple list format)
function generateGitOpsPoliciesYaml(rules: Rule[]): string {
  const policies = rules.map((rule) => {
    // Clean up description - remove newlines and limit length
    let description = (rule.description || "").replace(/\n/g, " ").trim();
    if (description.length > 500) {
      description = description.substring(0, 497) + "...";
    }

    // Build resolution with fix file reference
    let resolution = (
      rule.fixText || "Refer to STIG documentation for remediation steps."
    )
      .replace(/\n/g, " ")
      .trim();

    // Add fix file reference if available (Fleet-aligned paths)
    if (rule.fix) {
      const fixPath =
        rule.fix.type === "ps1"
          ? `../scripts/${rule.fix.filename}`
          : `../configuration-profiles/${rule.fix.filename}`;
      resolution = `Remediation: ${fixPath}\n\n${resolution}`;
    }

    if (resolution.length > 500) {
      resolution = resolution.substring(0, 497) + "...";
    }

    // Determine if critical based on severity
    const critical = rule.severity === "high";

    // Build query - use actual query or placeholder for manual checks
    const query =
      rule.query && !rule.query.includes("SELECT 0 WHERE 1=0")
        ? rule.query
        : `-- Manual check required: ${rule.ruleId}\nSELECT 0 WHERE 1=0;`;

    // Build the policy object
    const policy: {
      name: string;
      query: string;
      critical: boolean;
      description: string;
      resolution: string;
      platform: string;
      run_script?: { path: string };
    } = {
      name: `STIG ${rule.ruleId} - ${rule.title.replace(`${rule.ruleId} - `, "")}`,
      query,
      critical,
      description,
      resolution,
      platform: "windows",
    };

    // Add run_script for PS1 files only (Fleet schema - only scripts are executable)
    // XML files are configuration profiles deployed via MDM, not run_script
    if (rule.fix && rule.fix.type === "ps1") {
      policy.run_script = { path: `../scripts/${rule.fix.filename}` };
    }

    return policy;
  });

  // Convert to proper YAML list format
  return policies
    .map((p) => {
      let yaml = `- name: ${escapeYamlString(p.name)}\n`;

      // Handle multiline query
      if (p.query.includes("\n")) {
        yaml += `  query: |\n`;
        yaml +=
          p.query
            .split("\n")
            .map((line) => `    ${line}`)
            .join("\n") + "\n";
      } else {
        yaml += `  query: ${escapeYamlString(p.query)}\n`;
      }

      yaml += `  critical: ${p.critical}\n`;
      yaml += `  description: ${escapeYamlString(p.description)}\n`;
      yaml += `  resolution: ${escapeYamlString(p.resolution)}\n`;
      yaml += `  platform: ${p.platform}`;

      // Add run_script if available (Fleet schema)
      if (p.run_script) {
        yaml += `\n  run_script:\n    path: ${p.run_script.path}`;
      }

      return yaml;
    })
    .join("\n\n");
}

// Generate legacy format YAML (with apiVersion/kind)
function generateLegacyPoliciesYaml(rules: Rule[]): string {
  const policies = rules.map((rule) => {
    // Build resolution with fix file reference
    let resolution =
      rule.fixText || "Refer to STIG documentation for remediation steps.";
    if (rule.fix) {
      const fixPath = `fixes/${rule.fix.type}/${rule.fix.filename}`;
      resolution = `Remediation script: ${fixPath}\n\n${resolution}`;
    }

    const policy: Record<string, unknown> = {
      apiVersion: "v1",
      kind: "policy",
      spec: {
        name: `STIG - ${rule.title}`,
        platforms: "windows",
        platform: "windows",
        description: rule.description || "",
        resolution,
        query: rule.query || "-- Manual check required\nSELECT 0 WHERE 1=0;",
        purpose: "Informational",
        tags: `compliance, STIG, STIG_Win11_v2, severity_${rule.severity}`,
        contributors: "DISA STIG",
      },
    };

    // Add run_script for PS1 files only (Fleet schema)
    if (rule.fix && rule.fix.type === "ps1") {
      (policy.spec as Record<string, unknown>).run_script = {
        path: `../scripts/${rule.fix.filename}`,
      };
    }

    return policy;
  });

  return policies.map((p) => yamlStringify(p)).join("\n---\n");
}

// Escape string for YAML
function escapeYamlString(str: string): string {
  if (!str) return '""';

  // Check if needs quoting
  const needsQuotes =
    str.includes(":") ||
    str.includes("#") ||
    str.includes('"') ||
    str.includes("'") ||
    str.includes("\n") ||
    str.startsWith(" ") ||
    str.endsWith(" ") ||
    str.startsWith("-") ||
    str.startsWith("[") ||
    str.startsWith("{");

  if (needsQuotes) {
    // Use double quotes and escape internal quotes
    return `"${str.replace(/"/g, '\\"').replace(/\n/g, " ")}"`;
  }

  return str;
}

// Simple YAML stringifier for legacy format
function yamlStringify(obj: unknown, indent = 0): string {
  const spaces = "  ".repeat(indent);

  if (obj === null || obj === undefined) {
    return "null";
  }

  if (typeof obj === "string") {
    if (obj.includes("\n")) {
      const lines = obj
        .split("\n")
        .map((line) => spaces + "  " + line)
        .join("\n");
      return `|\n${lines}`;
    }
    if (
      obj.includes(":") ||
      obj.includes("#") ||
      obj.includes('"') ||
      obj.includes("'") ||
      obj.startsWith(" ") ||
      obj.endsWith(" ")
    ) {
      return `"${obj.replace(/"/g, '\\"')}"`;
    }
    return obj;
  }

  if (typeof obj === "number" || typeof obj === "boolean") {
    return String(obj);
  }

  if (Array.isArray(obj)) {
    if (obj.length === 0) return "[]";
    return obj
      .map(
        (item) => `${spaces}- ${yamlStringify(item, indent + 1).trimStart()}`,
      )
      .join("\n");
  }

  if (typeof obj === "object") {
    const entries = Object.entries(obj as Record<string, unknown>);
    if (entries.length === 0) return "{}";

    return entries
      .map(([key, value]) => {
        const valueStr = yamlStringify(value, indent + 1);
        if (
          typeof value === "object" &&
          value !== null &&
          !Array.isArray(value)
        ) {
          return `${spaces}${key}:\n${valueStr}`;
        }
        if (typeof value === "string" && value.includes("\n")) {
          return `${spaces}${key}: ${valueStr}`;
        }
        return `${spaces}${key}: ${valueStr}`;
      })
      .join("\n");
  }

  return String(obj);
}

// Generate README
function generateReadme(
  rules: Rule[],
  profileName: string,
  includeFixes: boolean,
  format: ExportFormat,
): string {
  const now = new Date().toISOString();
  const highCount = rules.filter((r) => r.severity === "high").length;
  const mediumCount = rules.filter((r) => r.severity === "medium").length;
  const lowCount = rules.filter((r) => r.severity === "low").length;
  const autoCount = rules.filter((r) => r.automatable).length;
  const fixCount = rules.filter((r) => r.fix).length;

  const formatDesc =
    format === "gitops"
      ? "Fleet GitOps format (simple list structure)"
      : "Legacy format (apiVersion/kind structure)";

  return `# ${profileName}

Generated by STIG Benchmark Builder on ${now}

## Summary

- **Format**: ${formatDesc}
- **Total Policies**: ${rules.length}
- **High Severity**: ${highCount}
- **Medium Severity**: ${mediumCount}
- **Low Severity**: ${lowCount}
- **Automatable**: ${autoCount}
- **With Fix Scripts**: ${fixCount}

## Contents

${
  format === "gitops"
    ? `### Structure

\`\`\`
${profileName}/
├── default.yml           # Main GitOps config
├── lib/
│   └── windows/
│       ├── policies/
│       │   └── stig*.policies.yml
${
  includeFixes
    ? `│       ├── scripts/                    # PowerShell remediation
│       │   └── *.ps1
│       └── configuration-profiles/     # MDM/CSP configs
│           └── *.xml
`
    : ""
}└── README.md
\`\`\`
`
    : `### policies/

Fleet policy YAML files for use with \`fleetctl\`.
`
}
${
  includeFixes
    ? `### Remediation Files

- \`lib/windows/scripts/\` - PowerShell remediation scripts (referenced via \`run_script\`)
- \`lib/windows/configuration-profiles/\` - MDM/CSP configuration files (deployed via MDM)

`
    : ""
}
## Usage

### Apply with Fleet GitOps

${
  format === "gitops"
    ? `\`\`\`bash
# Apply entire configuration
fleetctl gitops apply -f default.yml

# Or apply individual policy files
fleetctl gitops apply -f lib/windows/policies/stig.policies.yml
\`\`\`
`
    : `\`\`\`bash
fleetctl apply -f policies/
\`\`\`
`
}
### Import to Fleet UI

Upload the YAML files through Fleet's web interface under Policies.

${
  includeFixes
    ? `### Apply Fixes

**PowerShell Scripts** (run as Administrator):
\`\`\`powershell
Get-ChildItem -Path fixes/ps1/*.ps1 | ForEach-Object { & $_.FullName }
\`\`\`

**MDM/XML Configurations**:
Import through your MDM solution (Intune, SCCM, etc.)
`
    : ""
}
## Source

Windows 11 Security Technical Implementation Guide (STIG) v2
Published by: Defense Information Systems Agency (DISA)

## Links

- [Fleet GitOps Documentation](https://fleetdm.com/docs/configuration/yaml-files)
- [DISA STIG Library](https://public.cyber.mil/stigs/)
`;
}
